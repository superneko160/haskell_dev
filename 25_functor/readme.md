# Functor

## Fanctorとは

Functorは型クラスとして定義されていて、 `fmap` という関数を提供する

`fmap` は、ある型の値を別の型に変換する関数を受け取り、それをFunctorが包んでいる値に適用し、Functorが包んだまま別の型に変換された値を返す

```hs
class Functor f where
    fmap :: (a -> b) -> f a -> f b
```

ここで重要なのは `f` が型コンストラクタである点。たとえば `Maybe` や `[]`（リスト）などが型コンストラクタ。 `f a` は `Maybe a` や `[a]` のように具体的な型になる

要するに、Functorは「なにかを包んでいる構造（コンテナ）の中身を、その構造を変えずに変換する」ための抽象化された方法を提供する

つまり、ほかの言語でいう `map` である

```js
const numbers = [1, 2, 3];
const doubleNumbers = numbers.map(x => x * 2);  // [2, 4, 6]
```

上はJSのコードだが `map` メソッドを通しても、リスト構造自体は変化していない。これは「なにかを包んでいる構造の中身を、その構造を変えずに変換する」という `fmap` の性質と合致している

Haskellはこれを型レベルで与えている

### なぜFunctor という概念があるか

ほかの言語では `map` で済ませているような操作に、なぜHaskellはFunctorという型クラスを与えるのか

それはHaskellが型システムを通じてプログラミングのパターンを抽象化し、再利用可能な形で表現することを目指しているから

`[]` （リスト）も `Maybe` も `IO` も、さらにはユーザ定義の複雑なデータ型も、それぞれ異なるコンテナの形をしているが、「中身を変換し、コンテナの形は保つ」という共通の操作を持っている

Haskellは、この共通の操作をFunctorという型クラスとして定義することで、これらの異なるデータ型に対してポリモーフィックなコードを書くことが可能となる

「この型はFunctorのインスタンスだから、 `fmap` を使って中身を変換できるはずだ」という保証が、型システムレベルで得られる。これは、コードの予測可能性と安全性を高めることにつながる

